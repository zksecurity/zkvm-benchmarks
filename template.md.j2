- Overview of zkVM and Proof Systems

| zkVM / Proof System   | Architecture   | Frontend   | Backend       | Security Bits |
|:----------------------|:---------------|:-----------|:--------------|:--------------|
| [RISC Zero](https://github.com/risc0/risc0)             | RISC-V         | Rust       | STARK-based   | 96 bits       |
| [SP1](https://github.com/succinctlabs/sp1)       | RISC-V         | Rust       | STARK-based   | 100 bits      |
| [OpenVM](https://github.com/openvm-org/openvm)       | RISC-V         | Rust       | STARK-based   | 100 bits      |
| [Jolt](https://github.com/a16z/jolt)                  | RISC-V         | Rust       | Lookup-based  | -             |
| [Stone](https://github.com/starkware-libs/stone-prover)                 | Cairo VM       | Cairo      | STARK-based   | 100 bits      |
| [Stwo](https://github.com/starkware-libs/stwo)                  | Cairo VM       | Cairo      | STARK-based   | 96 bits       |

- Stone benchmarks were generated using the `dynamic` layout with the following configurations:
    - Parameters - `fri_step_list` and `last_layer_degree_bound` change depending on the size of the computation but other parameters remain same

        ```
        {
            "field": "PrimeField0",
            "channel_hash": "keccak256",
            "commitment_hash": "keccak256_masked160_lsb",
            "n_verifier_friendly_commitment_layers": 0,
            "pow_hash": "keccak256",
            "statement": {
                "page_hash": "pedersen"
            },
            "stark": {
                "fri": {
                    "fri_step_list": [
                        0,
                        3,
                        3,
                        3,
                        3,
                        2
                    ],
                    "last_layer_degree_bound": 64,
                    "n_queries": 16,
                    "proof_of_work_bits": 20
                },
                "log_n_cosets": 5
            },
            "use_extension_field": false,
            "verifier_friendly_channel_updates": false,
            "verifier_friendly_commitment_hash": "poseidon3"
        }
        ```
    - Prover Config

        ```
        {
            "cached_lde_config": {
                "store_full_lde": true,
                "use_fft_for_eval": false
            },
            "constraint_polynomial_task_size": 256,
            "n_out_of_memory_merkle_layers": 0,
            "table_prover_n_tasks_per_segment": 32
        }
        ```
- Benchmarks which run out of memory have been indicate by `*` in the tables.


## Time and Commit Hash
- **Commit Hash**: {{ commit_hash }}
- **Timestamp**: {{ time }}


## System Information

### OS Version
{{ os_version }}

### CPU Info
{% for key, value in cpu_info.items() %}
- **{{ key }}**: {{ value }}
{% endfor %}

### Memory Info
{% for key, value in mem_info.items() %}
- **{{ key }}**: {{ value }}
{% endfor %}


## Fibonacci
Benchmark `n` Fibonacci iterations.

### Prover Time (s)
{{ fib_data.tables.prover_time }}

![]({{ fib_data.plots.prover_time_plot }})

### Verifier Time (ms) 
{{ fib_data.tables.verifier_time }}

![]({{ fib_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ fib_data.tables.proof_size }}

![]({{ fib_data.plots.proof_size_plot }})

### Cycle Count
{{ fib_data.tables.cycle_count }}

![]({{ fib_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ fib_data.tables.peak_memory }}

![]({{ fib_data.plots.peak_memory_plot }})


## Sha2
Benchmark Sha256 hash of `n` bytes. For Stone, the [cairo implementation of sha256](https://github.com/cartridge-gg/cairo-sha256) by cartridge was used for benchmarking and for other zkvms [sha2 Rust crate](https://crates.io/crates/sha2) was used for benchmarking.

### Prover Time (s)
{{ sha2_data.tables.prover_time }}

![]({{ sha2_data.plots.prover_time_plot }})

### Verifier Time (ms)
{{ sha2_data.tables.verifier_time }}

![]({{ sha2_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ sha2_data.tables.proof_size }}

![]({{ sha2_data.plots.proof_size_plot }})

### Cycle Count
{{ sha2_data.tables.cycle_count }}

![]({{ sha2_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ sha2_data.tables.peak_memory }}

![]({{ sha2_data.plots.peak_memory_plot }})

## Sha2-Chain
Benchmark Sha256 hash of 32 bytes for `n` iteration.

### Prover Time (s)
{{ sha2_chain_data.tables.prover_time }}

![]({{ sha2_chain_data.plots.prover_time_plot }})

### Verifier Time (ms)
{{ sha2_chain_data.tables.verifier_time }}

![]({{ sha2_chain_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ sha2_chain_data.tables.proof_size }}

![]({{ sha2_chain_data.plots.proof_size_plot }})

### Cycle Count
{{ sha2_chain_data.tables.cycle_count }}

![]({{ sha2_chain_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ sha2_chain_data.tables.peak_memory }}

![]({{ sha2_chain_data.plots.peak_memory_plot }})


## Sha3
Benchmark Keccak256 hash of `n` bytes. For Stone, the implementation of Keccak256 from stdlib as well as builtin was benchmarked.

### Prover Time (s)
{{ sha3_data.tables.prover_time }}

![]({{ sha3_data.plots.prover_time_plot }})

### Verifier Time (ms)
{{ sha3_data.tables.verifier_time }}

![]({{ sha3_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ sha3_data.tables.proof_size }}

![]({{ sha3_data.plots.proof_size_plot }})

### Cycle Count
{{ sha3_data.tables.cycle_count }}

![]({{ sha3_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ sha3_data.tables.peak_memory }}

![]({{ sha3_data.plots.peak_memory_plot }})

**Stone benchmark with Keccak Builtin**: The function call to the keccak builtin allows max 200 bytes per iteration. So the following benchmarks are hashing multiples of 200 byts.

{{ stone_sha3_builtin_table }}


## Sha3-Chain
Benchmark Keccak256 hash of 32 bytes for `n` iteration.

### Prover Time (s)
{{ sha3_chain_data.tables.prover_time }}

![]({{ sha3_chain_data.plots.prover_time_plot }})

### Verifier Time (ms)
{{ sha3_chain_data.tables.verifier_time }}

![]({{ sha3_chain_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ sha3_chain_data.tables.proof_size }}

![]({{ sha3_chain_data.plots.proof_size_plot }})

### Cycle Count
{{ sha3_chain_data.tables.cycle_count }}

![]({{ sha3_chain_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ sha3_chain_data.tables.peak_memory }}

![]({{ sha3_chain_data.plots.peak_memory_plot }})

**Stone benchmark with Keccak Builtin**: The function call to the keccak builtin allows max 200 bytes per iteration. So the following benchmarks can be interpreted as hashing `200 * n` bytes data, such as `200 * 37 = 7400` and so on.

{{ stone_sha3_chain_builtin_table }}

## Matrix Multiplication
Benchmark multiplication of two matrices of size n x n.

### Prover Time (s)
{{ mat_mul_data.tables.prover_time }}

![]({{ mat_mul_data.plots.prover_time_plot }})

### Verifier Time (ms)
{{ mat_mul_data.tables.verifier_time }}

![]({{ mat_mul_data.plots.verifier_time_plot }})

### Proof Size (KB)
{{ mat_mul_data.tables.proof_size }}

![]({{ mat_mul_data.plots.proof_size_plot }})

### Cycle Count
{{ mat_mul_data.tables.cycle_count }}

![]({{ mat_mul_data.plots.cycle_count_plot }})

### Peak Memory (GB)
{{ mat_mul_data.tables.peak_memory }}

![]({{ mat_mul_data.plots.peak_memory_plot }})